<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PSP Emulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
            touch-action: none;
        }

        #app {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        #main-menu.hidden {
            display: none;
        }

        .menu-title {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .menu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 800px;
            padding: 20px;
        }

        .menu-item {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .menu-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .menu-item h3 {
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .menu-item p {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .file-input {
            display: none;
        }

        #emulator-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: none;
            background: #000;
        }

        #emulator-container.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #screen-canvas {
            max-width: 100%;
            max-height: 70vh;
            image-rendering: pixelated;
            border: 3px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        #menu-button {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(102, 126, 234, 0.9);
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            z-index: 999;
            display: none;
            transition: all 0.3s;
        }

        #menu-button:hover {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.05);
        }

        #menu-button.visible {
            display: block;
        }

        #touch-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            display: none;
            z-index: 500;
        }

        #touch-controls.active {
            display: block;
        }

        .touch-button {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
            touch-action: none;
        }

        .touch-button:active {
            background: rgba(255,255,255,0.4);
        }

        .dpad {
            position: absolute;
            left: 30px;
            bottom: 80px;
            width: 140px;
            height: 140px;
        }

        .dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
        .dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        .dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
        .dpad-right { right: 0; top: 50%; transform: translateY(-50%); }

        .action-buttons {
            position: absolute;
            right: 30px;
            bottom: 80px;
            width: 140px;
            height: 140px;
        }

        .btn-triangle { top: 0; left: 50%; transform: translateX(-50%); }
        .btn-cross { bottom: 0; left: 50%; transform: translateX(-50%); }
        .btn-square { left: 0; top: 50%; transform: translateY(-50%); }
        .btn-circle { right: 0; top: 50%; transform: translateY(-50%); }

        .shoulder-buttons {
            position: absolute;
            top: 10px;
            width: 100%;
        }

        .btn-l { left: 10px; }
        .btn-r { right: 10px; }

        #debug-console {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-y: auto;
            padding: 10px;
            display: none;
            z-index: 600;
        }

        #debug-console.active {
            display: block;
        }

        .status-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            font-size: 12px;
            display: none;
            z-index: 500;
        }

        .status-bar.active {
            display: flex;
            justify-content: space-between;
        }

        .btn {
            background: rgba(102, 126, 234, 0.9);
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.05);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #2a2a3e;
            border-radius: 10px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 1.8em;
            margin-bottom: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .key-binding {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
        }

        .key-binding button {
            padding: 5px 15px;
        }

        @media (orientation: landscape) {
            #screen-canvas {
                max-height: 85vh;
            }
        }

        .fullscreen #screen-canvas {
            max-width: 100vw;
            max-height: 100vh;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="main-menu">
            <div class="menu-title">üéÆ PSP Emulator</div>
            <div class="menu-grid">
                <div class="menu-item" onclick="loadFile('bios')">
                    <h3>üì¶ Load BIOS</h3>
                    <p>Load PSP firmware file</p>
                </div>
                <div class="menu-item" onclick="loadFile('iso')">
                    <h3>üíø Load ISO/CHD</h3>
                    <p>Load game dump</p>
                </div>
                <div class="menu-item" onclick="loadFile('cheats')">
                    <h3>üéØ Load Cheats</h3>
                    <p>Load .db or .ini cheats</p>
                </div>
                <div class="menu-item" onclick="loadFile('plugin')">
                    <h3>üîå Load Plugin</h3>
                    <p>Load ZIP plugin</p>
                </div>
                <div class="menu-item" onclick="openControlsModal()">
                    <h3>üéÆ Controls</h3>
                    <p>Remap keyboard controls</p>
                </div>
                <div class="menu-item" onclick="toggleDebug()">
                    <h3>üêõ Debug Mode</h3>
                    <p>Toggle debug console</p>
                </div>
                <div class="menu-item" onclick="exportSaveData()">
                    <h3>üíæ Export Save</h3>
                    <p>Export save data</p>
                </div>
                <div class="menu-item" onclick="importSaveData()">
                    <h3>üì• Import Save</h3>
                    <p>Import save data</p>
                </div>
                <div class="menu-item" onclick="saveState()">
                    <h3>üí´ Save State</h3>
                    <p>Quick save state</p>
                </div>
                <div class="menu-item" onclick="loadState()">
                    <h3>üìÇ Load State</h3>
                    <p>Quick load state</p>
                </div>
                <div class="menu-item" onclick="startEmulator()">
                    <h3>‚ñ∂Ô∏è Start</h3>
                    <p>Begin emulation</p>
                </div>
                <div class="menu-item" onclick="toggleFullscreen()">
                    <h3>üñ•Ô∏è Fullscreen</h3>
                    <p>Toggle fullscreen mode</p>
                </div>
            </div>
        </div>

        <div id="emulator-container">
            <canvas id="screen-canvas" width="480" height="272"></canvas>
        </div>

        <button id="menu-button" onclick="toggleMenu()">‚ò∞ Menu</button>

        <div id="touch-controls">
            <div class="dpad">
                <div class="touch-button dpad-up" data-button="up">‚ñ≤</div>
                <div class="touch-button dpad-down" data-button="down">‚ñº</div>
                <div class="touch-button dpad-left" data-button="left">‚óÄ</div>
                <div class="touch-button dpad-right" data-button="right">‚ñ∂</div>
            </div>
            <div class="action-buttons">
                <div class="touch-button btn-triangle" data-button="triangle">‚ñ≥</div>
                <div class="touch-button btn-cross" data-button="cross">‚úï</div>
                <div class="touch-button btn-square" data-button="square">‚ñ°</div>
                <div class="touch-button btn-circle" data-button="circle">‚óã</div>
            </div>
            <div class="shoulder-buttons">
                <div class="touch-button btn-l" data-button="L">L</div>
                <div class="touch-button btn-r" data-button="R">R</div>
            </div>
        </div>

        <div id="debug-console"></div>

        <div class="status-bar">
            <span id="fps-counter">FPS: 0</span>
            <span id="status-text">Ready</span>
        </div>

        <div id="controls-modal" class="modal">
            <div class="modal-content">
                <div class="modal-title">Keyboard Controls</div>
                <div id="key-bindings"></div>
                <button class="btn" onclick="closeControlsModal()">Close</button>
            </div>
        </div>

        <input type="file" id="file-input" class="file-input" accept="*">
    </div>

    <script>
        const PSP_SCREEN_WIDTH = 480;
        const PSP_SCREEN_HEIGHT = 272;
        const MEMORY_SIZE = 32 * 1024 * 1024;
        const VRAM_SIZE = 2 * 1024 * 1024;

        class PSPEmulator {
            constructor() {
                this.canvas = document.getElementById('screen-canvas');
                this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                this.ctx2d = null;
                
                if (!this.gl) {
                    this.ctx2d = this.canvas.getContext('2d');
                    this.debugLog('WebGL not available, using 2D context');
                }

                this.memory = new ArrayBuffer(MEMORY_SIZE);
                this.ram = new Uint8Array(this.memory);
                this.vram = new Uint8Array(VRAM_SIZE);
                
                this.cpu = new PSPCPU(this);
                this.gpu = new PSPGPU(this);
                this.audio = new PSPAudio(this);
                
                this.bios = null;
                this.iso = null;
                this.cheats = [];
                this.plugins = [];
                
                this.running = false;
                this.paused = false;
                this.debugMode = false;
                
                this.fps = 0;
                this.frameCount = 0;
                this.lastFPSUpdate = Date.now();
                
                this.initKeyboardControls();
                this.initTouchControls();
                this.initIndexedDB();
                
                this.debugLog('PSP Emulator initialized');
            }

            initKeyboardControls() {
                this.keyMap = {
                    'ArrowUp': 'up',
                    'ArrowDown': 'down',
                    'ArrowLeft': 'left',
                    'ArrowRight': 'right',
                    'KeyX': 'cross',
                    'KeyZ': 'circle',
                    'KeyA': 'square',
                    'KeyS': 'triangle',
                    'KeyQ': 'L',
                    'KeyW': 'R',
                    'Enter': 'start',
                    'ShiftRight': 'select'
                };

                this.buttonStates = {};
                
                window.addEventListener('keydown', (e) => {
                    const button = this.keyMap[e.code];
                    if (button) {
                        this.buttonStates[button] = true;
                        e.preventDefault();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    const button = this.keyMap[e.code];
                    if (button) {
                        this.buttonStates[button] = false;
                        e.preventDefault();
                    }
                });
            }

            initTouchControls() {
                const touchButtons = document.querySelectorAll('.touch-button');
                touchButtons.forEach(btn => {
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const button = btn.dataset.button;
                        this.buttonStates[button] = true;
                    });

                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        const button = btn.dataset.button;
                        this.buttonStates[button] = false;
                    });
                });
            }

            initIndexedDB() {
                const request = indexedDB.open('PSPEmulatorDB', 1);
                
                request.onerror = () => {
                    this.debugLog('IndexedDB error');
                };

                request.onsuccess = (e) => {
                    this.db = e.target.result;
                    this.debugLog('IndexedDB ready');
                };

                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('saves')) {
                        db.createObjectStore('saves', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('states')) {
                        db.createObjectStore('states', { keyPath: 'slot' });
                    }
                };
            }

            loadBIOS(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.bios = new Uint8Array(e.target.result);
                    this.debugLog(`BIOS loaded: ${this.bios.length} bytes`);
                    this.ram.set(this.bios, 0);
                };
                reader.readAsArrayBuffer(file);
            }

            loadISO(file) {
                this.debugLog(`Loading ${file.name}...`);
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = new Uint8Array(e.target.result);
                    
                    if (file.name.endsWith('.chd')) {
                        this.iso = this.parseCHD(data);
                    } else {
                        this.iso = data;
                    }
                    
                    this.debugLog(`ISO loaded: ${this.iso.length} bytes`);
                    this.parseISO();
                };
                reader.readAsArrayBuffer(file);
            }

            parseCHD(data) {
                this.debugLog('Parsing CHD format...');
                const signature = String.fromCharCode(...data.slice(0, 8));
                if (!signature.startsWith('MComprHD')) {
                    this.debugLog('Invalid CHD file');
                    return data;
                }
                return data;
            }

            parseISO() {
                if (!this.iso) return;
                
                this.debugLog('Parsing ISO9660 filesystem...');
                
                const volumeDescriptor = this.iso.slice(0x8000, 0x8800);
                const identifier = String.fromCharCode(...volumeDescriptor.slice(1, 6));
                
                if (identifier === 'CD001') {
                    this.debugLog('Valid ISO9660 filesystem detected');
                    const volumeLabel = String.fromCharCode(...volumeDescriptor.slice(40, 72)).trim();
                    this.debugLog(`Volume: ${volumeLabel}`);
                }
            }

            loadCheats(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    
                    if (file.name.endsWith('.db')) {
                        this.parseCheatsDB(content);
                    } else if (file.name.endsWith('.ini')) {
                        this.parseCheatsINI(content);
                    }
                    
                    this.debugLog(`Loaded ${this.cheats.length} cheats`);
                };
                reader.readAsText(file);
            }

            parseCheatsDB(content) {
                const lines = content.split('\n');
                let currentCheat = null;
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('_S')) {
                        if (currentCheat) this.cheats.push(currentCheat);
                        currentCheat = { name: trimmed.substring(3), codes: [] };
                    } else if (trimmed.startsWith('_L') && currentCheat) {
                        const code = trimmed.substring(3);
                        currentCheat.codes.push(code);
                    }
                }
                
                if (currentCheat) this.cheats.push(currentCheat);
            }

            parseCheatsINI(content) {
                const lines = content.split('\n');
                let currentCheat = null;
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
                        if (currentCheat) this.cheats.push(currentCheat);
                        currentCheat = { name: trimmed.slice(1, -1), codes: [] };
                    } else if (trimmed && currentCheat && trimmed.includes('=')) {
                        const [addr, value] = trimmed.split('=');
                        currentCheat.codes.push(`${addr} ${value}`);
                    }
                }
                
                if (currentCheat) this.cheats.push(currentCheat);
            }

            loadPlugin(file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const zipData = new Uint8Array(e.target.result);
                        const plugin = await this.parseZIP(zipData);
                        this.plugins.push(plugin);
                        this.debugLog(`Plugin loaded: ${file.name}`);
                    } catch (err) {
                        this.debugLog(`Plugin error: ${err.message}`);
                    }
                };
                reader.readAsArrayBuffer(file);
            }

            async parseZIP(data) {
                const sig = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
                if (sig !== 0x04034b50) {
                    throw new Error('Invalid ZIP file');
                }
                
                const plugin = {
                    files: {},
                    metadata: {}
                };
                
                let offset = 0;
                while (offset < data.length - 4) {
                    const localSig = data[offset] | (data[offset+1] << 8) | (data[offset+2] << 16) | (data[offset+3] << 24);
                    
                    if (localSig !== 0x04034b50) break;
                    
                    const filenameLen = data[offset + 26] | (data[offset + 27] << 8);
                    const extraLen = data[offset + 28] | (data[offset + 29] << 8);
                    const compSize = data[offset + 18] | (data[offset + 19] << 8) | (data[offset + 20] << 16) | (data[offset + 21] << 24);
                    
                    const nameStart = offset + 30;
                    const filename = String.fromCharCode(...data.slice(nameStart, nameStart + filenameLen));
                    
                    const dataStart = nameStart + filenameLen + extraLen;
                    const fileData = data.slice(dataStart, dataStart + compSize);
                    
                    plugin.files[filename] = fileData;
                    
                    offset = dataStart + compSize;
                }
                
                return plugin;
            }

            applyCheats() {
                for (const cheat of this.cheats) {
                    for (const code of cheat.codes) {
                        const parts = code.split(' ');
                        if (parts.length >= 2) {
                            const addr = parseInt(parts[0], 16);
                            const value = parseInt(parts[1], 16);
                            
                            if (addr < this.ram.length) {
                                this.ram[addr] = value & 0xFF;
                                if (parts.length > 2) {
                                    this.ram[addr + 1] = (value >> 8) & 0xFF;
                                }
                            }
                        }
                    }
                }
            }

            start() {
                if (!this.bios) {
                    this.debugLog('No BIOS loaded - starting in HLE mode');
                }
                
                if (!this.iso) {
                    this.debugLog('No ISO loaded');
                    return;
                }

                this.running = true;
                this.cpu.reset();
                this.gpu.reset();
                
                this.debugLog('Emulator started');
                this.mainLoop();
            }

            mainLoop() {
                if (!this.running || this.paused) {
                    requestAnimationFrame(() => this.mainLoop());
                    return;
                }

                this.cpu.executeFrame();
                this.gpu.renderFrame();
                
                if (this.cheats.length > 0) {
                    this.applyCheats();
                }

                this.frameCount++;
                const now = Date.now();
                if (now - this.lastFPSUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFPSUpdate = now;
                    document.getElementById('fps-counter').textContent = `FPS: ${this.fps}`;
                }

                requestAnimationFrame(() => this.mainLoop());
            }

            pause() {
                this.paused = !this.paused;
                this.debugLog(this.paused ? 'Paused' : 'Resumed');
            }

            saveState(slot = 0) {
                if (!this.db) {
                    this.debugLog('Database not ready');
                    return;
                }

                const state = {
                    slot: slot,
                    timestamp: Date.now(),
                    ram: Array.from(this.ram),
                    vram: Array.from(this.vram),
                    cpu: this.cpu.getState(),
                    gpu: this.gpu.getState()
                };

                const transaction = this.db.transaction(['states'], 'readwrite');
                const store = transaction.objectStore('states');
                store.put(state);

                this.debugLog(`State saved to slot ${slot}`);
            }

            loadState(slot = 0) {
                if (!this.db) {
                    this.debugLog('Database not ready');
                    return;
                }

                const transaction = this.db.transaction(['states'], 'readonly');
                const store = transaction.objectStore('states');
                const request = store.get(slot);

                request.onsuccess = () => {
                    const state = request.result;
                    if (state) {
                        this.ram.set(new Uint8Array(state.ram));
                        this.vram.set(new Uint8Array(state.vram));
                        this.cpu.setState(state.cpu);
                        this.gpu.setState(state.gpu);
                        this.debugLog(`State loaded from slot ${slot}`);
                    } else {
                        this.debugLog(`No state in slot ${slot}`);
                    }
                };
            }

            exportSaveData() {
                if (!this.db) {
                    this.debugLog('Database not ready');
                    return;
                }

                const transaction = this.db.transaction(['saves'], 'readonly');
                const store = transaction.objectStore('saves');
                const request = store.getAll();

                request.onsuccess = () => {
                    const saves = request.result;
                    const blob = new Blob([JSON.stringify(saves, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'psp_savedata.json';
                    a.click();
                    URL.revokeObjectURL(url);
                    this.debugLog('Save data exported');
                };
            }

            importSaveData(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const saves = JSON.parse(e.target.result);
                        const transaction = this.db.transaction(['saves'], 'readwrite');
                        const store = transaction.objectStore('saves');
                        
                        for (const save of saves) {
                            store.put(save);
                        }
                        
                        this.debugLog('Save data imported');
                    } catch (err) {
                        this.debugLog(`Import error: ${err.message}`);
                    }
                };
                reader.readAsText(file);
            }

            debugLog(message) {
                if (this.debugMode) {
                    const console = document.getElementById('debug-console');
                    const timestamp = new Date().toLocaleTimeString();
                    console.innerHTML += `[${timestamp}] ${message}\n`;
                    console.scrollTop = console.scrollHeight;
                }
                console.log(`[PSP] ${message}`);
            }
        }

        class PSPCPU {
            constructor(emulator) {
                this.emu = emulator;
                this.pc = 0;
                this.registers = new Int32Array(32);
                this.hi = 0;
                this.lo = 0;
                this.cycles = 0;
            }

            reset() {
                this.pc = 0x04000000;
                this.registers.fill(0);
                this.hi = 0;
                this.lo = 0;
                this.cycles = 0;
                this.emu.debugLog('CPU reset');
            }

            executeFrame() {
                const cyclesPerFrame = 333000000 / 60;
                const targetCycles = this.cycles + cyclesPerFrame;

                while (this.cycles < targetCycles && this.emu.running) {
                    this.executeInstruction();
                    this.cycles += 1;
                }
            }

            executeInstruction() {
                if (this.pc >= this.emu.ram.length - 4) {
                    return;
                }

                const instruction = this.fetchInstruction();
                this.decodeAndExecute(instruction);
                this.pc += 4;
            }

            fetchInstruction() {
                const offset = this.pc & 0x1FFFFFFF;
                if (offset >= this.emu.ram.length - 4) return 0;
                
                return this.emu.ram[offset] |
                       (this.emu.ram[offset + 1] << 8) |
                       (this.emu.ram[offset + 2] << 16) |
                       (this.emu.ram[offset + 3] << 24);
            }

            decodeAndExecute(instruction) {
                const opcode = (instruction >> 26) & 0x3F;
                const rs = (instruction >> 21) & 0x1F;
                const rt = (instruction >> 16) & 0x1F;
                const rd = (instruction >> 11) & 0x1F;
                const shamt = (instruction >> 6) & 0x1F;
                const funct = instruction & 0x3F;
                const imm = instruction & 0xFFFF;
                const signedImm = (imm & 0x8000) ? (imm | 0xFFFF0000) : imm;

                switch (opcode) {
                    case 0x00:
                        switch (funct) {
                            case 0x00:
                                this.registers[rd] = this.registers[rt] << shamt;
                                break;
                            case 0x20:
                                this.registers[rd] = this.registers[rs] + this.registers[rt];
                                break;
                            case 0x22:
                                this.registers[rd] = this.registers[rs] - this.registers[rt];
                                break;
                            case 0x24:
                                this.registers[rd] = this.registers[rs] & this.registers[rt];
                                break;
                            case 0x25:
                                this.registers[rd] = this.registers[rs] | this.registers[rt];
                                break;
                            case 0x08:
                                this.pc = this.registers[rs] - 4;
                                break;
                        }
                        break;
                    case 0x08:
                        this.registers[rt] = this.registers[rs] + signedImm;
                        break;
                    case 0x0D:
                        this.registers[rt] = this.registers[rs] | imm;
                        break;
                    case 0x0F:
                        this.registers[rt] = imm << 16;
                        break;
                    case 0x23:
                        const loadAddr = (this.registers[rs] + signedImm) & 0x1FFFFFFF;
                        if (loadAddr < this.emu.ram.length - 4) {
                            this.registers[rt] = this.emu.ram[loadAddr] |
                                               (this.emu.ram[loadAddr + 1] << 8) |
                                               (this.emu.ram[loadAddr + 2] << 16) |
                                               (this.emu.ram[loadAddr + 3] << 24);
                        }
                        break;
                    case 0x2B:
                        const storeAddr = (this.registers[rs] + signedImm) & 0x1FFFFFFF;
                        if (storeAddr < this.emu.ram.length - 4) {
                            const value = this.registers[rt];
                            this.emu.ram[storeAddr] = value & 0xFF;
                            this.emu.ram[storeAddr + 1] = (value >> 8) & 0xFF;
                            this.emu.ram[storeAddr + 2] = (value >> 16) & 0xFF;
                            this.emu.ram[storeAddr + 3] = (value >> 24) & 0xFF;
                        }
                        break;
                }

                this.registers[0] = 0;
            }

            getState() {
                return {
                    pc: this.pc,
                    registers: Array.from(this.registers),
                    hi: this.hi,
                    lo: this.lo,
                    cycles: this.cycles
                };
            }

            setState(state) {
                this.pc = state.pc;
                this.registers.set(state.registers);
                this.hi = state.hi;
                this.lo = state.lo;
                this.cycles = state.cycles;
            }
        }

        class PSPGPU {
            constructor(emulator) {
                this.emu = emulator;
                this.displayList = [];
                this.textureCache = new Map();
                this.vertices = [];
                this.matrices = {
                    projection: this.createIdentityMatrix(),
                    view: this.createIdentityMatrix(),
                    world: this.createIdentityMatrix()
                };
                
                if (this.emu.gl) {
                    this.initWebGL();
                }
            }

            initWebGL() {
                const gl = this.emu.gl;
                
                const vertexShaderSource = `
                    attribute vec3 aPosition;
                    attribute vec2 aTexCoord;
                    attribute vec4 aColor;
                    
                    uniform mat4 uProjection;
                    uniform mat4 uView;
                    uniform mat4 uWorld;
                    
                    varying vec2 vTexCoord;
                    varying vec4 vColor;
                    
                    void main() {
                        gl_Position = uProjection * uView * uWorld * vec4(aPosition, 1.0);
                        vTexCoord = aTexCoord;
                        vColor = aColor;
                    }
                `;

                const fragmentShaderSource = `
                    precision mediump float;
                    
                    varying vec2 vTexCoord;
                    varying vec4 vColor;
                    
                    uniform sampler2D uTexture;
                    uniform bool uUseTexture;
                    
                    void main() {
                        if (uUseTexture) {
                            gl_FragColor = texture2D(uTexture, vTexCoord) * vColor;
                        } else {
                            gl_FragColor = vColor;
                        }
                    }
                `;

                const vertexShader = this.compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    this.emu.debugLog('Shader program failed to link');
                    return;
                }

                this.attributes = {
                    position: gl.getAttribLocation(this.program, 'aPosition'),
                    texCoord: gl.getAttribLocation(this.program, 'aTexCoord'),
                    color: gl.getAttribLocation(this.program, 'aColor')
                };

                this.uniforms = {
                    projection: gl.getUniformLocation(this.program, 'uProjection'),
                    view: gl.getUniformLocation(this.program, 'uView'),
                    world: gl.getUniformLocation(this.program, 'uWorld'),
                    texture: gl.getUniformLocation(this.program, 'uTexture'),
                    useTexture: gl.getUniformLocation(this.program, 'uUseTexture')
                };

                this.vertexBuffer = gl.createBuffer();
                this.texCoordBuffer = gl.createBuffer();
                this.colorBuffer = gl.createBuffer();

                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            }

            compileShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    this.emu.debugLog('Shader compilation error: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            reset() {
                this.displayList = [];
                this.vertices = [];
                this.emu.debugLog('GPU reset');
            }

            renderFrame() {
                if (this.emu.gl) {
                    this.renderWebGL();
                } else if (this.emu.ctx2d) {
                    this.render2D();
                }
            }

            renderWebGL() {
                const gl = this.emu.gl;
                
                gl.viewport(0, 0, this.emu.canvas.width, this.emu.canvas.height);
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                gl.useProgram(this.program);

                gl.uniformMatrix4fv(this.uniforms.projection, false, this.matrices.projection);
                gl.uniformMatrix4fv(this.uniforms.view, false, this.matrices.view);
                gl.uniformMatrix4fv(this.uniforms.world, false, this.matrices.world);

                if (this.vertices.length > 0) {
                    this.drawVertices();
                } else {
                    this.drawTestPattern();
                }
            }

            drawVertices() {
                const gl = this.emu.gl;

                const positions = [];
                const texCoords = [];
                const colors = [];

                for (const v of this.vertices) {
                    positions.push(v.x, v.y, v.z);
                    texCoords.push(v.u || 0, v.v || 0);
                    colors.push(v.r || 1, v.g || 1, v.b || 1, v.a || 1);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(this.attributes.position);
                gl.vertexAttribPointer(this.attributes.position, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(this.attributes.texCoord);
                gl.vertexAttribPointer(this.attributes.texCoord, 2, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(this.attributes.color);
                gl.vertexAttribPointer(this.attributes.color, 4, gl.FLOAT, false, 0, 0);

                gl.uniform1i(this.uniforms.useTexture, 0);
                gl.drawArrays(gl.TRIANGLES, 0, this.vertices.length);
            }

            drawTestPattern() {
                const gl = this.emu.gl;
                
                const positions = [
                    -0.5, -0.5, 0.0,
                     0.5, -0.5, 0.0,
                     0.0,  0.5, 0.0
                ];

                const colors = [
                    1.0, 0.0, 0.0, 1.0,
                    0.0, 1.0, 0.0, 1.0,
                    0.0, 0.0, 1.0, 1.0
                ];

                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.attributes.position);
                gl.vertexAttribPointer(this.attributes.position, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.attributes.color);
                gl.vertexAttribPointer(this.attributes.color, 4, gl.FLOAT, false, 0, 0);

                gl.uniform1i(this.uniforms.useTexture, 0);
                gl.drawArrays(gl.TRIANGLES, 0, 3);
            }

            render2D() {
                const ctx = this.emu.ctx2d;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, this.emu.canvas.width, this.emu.canvas.height);

                ctx.fillStyle = '#fff';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('PSP Emulator Running', this.emu.canvas.width / 2, this.emu.canvas.height / 2);
                ctx.font = '14px monospace';
                ctx.fillText('Load BIOS and ISO to begin', this.emu.canvas.width / 2, this.emu.canvas.height / 2 + 30);
            }

            createIdentityMatrix() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }

            getState() {
                return {
                    displayList: [...this.displayList],
                    vertices: [...this.vertices]
                };
            }

            setState(state) {
                this.displayList = [...state.displayList];
                this.vertices = [...state.vertices];
            }
        }

        class PSPAudio {
            constructor(emulator) {
                this.emu = emulator;
                this.audioContext = null;
                this.initAudio();
            }

            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.emu.debugLog('Audio initialized');
                } catch (e) {
                    this.emu.debugLog('Audio not available');
                }
            }

            playSound(frequency, duration) {
                if (!this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.value = frequency;
                gainNode.gain.value = 0.1;

                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }
        }

        let emulator = null;
        let currentFileType = null;

        function initEmulator() {
            if (!emulator) {
                emulator = new PSPEmulator();
            }
        }

        function loadFile(type) {
            currentFileType = type;
            const input = document.getElementById('file-input');
            
            switch (type) {
                case 'bios':
                    input.accept = '.bin,.rom';
                    break;
                case 'iso':
                    input.accept = '.iso,.cso,.chd';
                    break;
                case 'cheats':
                    input.accept = '.db,.ini';
                    break;
                case 'plugin':
                    input.accept = '.zip';
                    break;
                case 'savedata':
                    input.accept = '.json';
                    break;
            }
            
            input.click();
        }

        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            initEmulator();

            switch (currentFileType) {
                case 'bios':
                    emulator.loadBIOS(file);
                    break;
                case 'iso':
                    emulator.loadISO(file);
                    break;
                case 'cheats':
                    emulator.loadCheats(file);
                    break;
                case 'plugin':
                    emulator.loadPlugin(file);
                    break;
                case 'savedata':
                    emulator.importSaveData(file);
                    break;
            }

            e.target.value = '';
        });

        function startEmulator() {
            initEmulator();
            
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('emulator-container').classList.add('active');
            document.getElementById('menu-button').classList.add('visible');
            document.querySelector('.status-bar').classList.add('active');
            
            if ('ontouchstart' in window) {
                document.getElementById('touch-controls').classList.add('active');
            }

            emulator.start();
        }

        function toggleMenu() {
            const menu = document.getElementById('main-menu');
            menu.classList.toggle('hidden');
        }

        function toggleDebug() {
            initEmulator();
            emulator.debugMode = !emulator.debugMode;
            document.getElementById('debug-console').classList.toggle('active');
        }

        function saveState() {
            initEmulator();
            emulator.saveState(0);
        }

        function loadState() {
            initEmulator();
            emulator.loadState(0);
        }

        function exportSaveData() {
            initEmulator();
            emulator.exportSaveData();
        }

        function importSaveData() {
            loadFile('savedata');
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                document.body.classList.add('fullscreen');
            } else {
                document.exitFullscreen();
                document.body.classList.remove('fullscreen');
            }
        }

        function openControlsModal() {
            initEmulator();
            
            const modal = document.getElementById('controls-modal');
            const bindingsDiv = document.getElementById('key-bindings');
            
            bindingsDiv.innerHTML = '';
            
            for (const [key, button] of Object.entries(emulator.keyMap)) {
                const binding = document.createElement('div');
                binding.className = 'key-binding';
                binding.innerHTML = `
                    <span>${button.toUpperCase()}</span>
                    <button class="btn" onclick="remapKey('${button}')">${key}</button>
                `;
                bindingsDiv.appendChild(binding);
            }
            
            modal.classList.add('active');
        }

        function closeControlsModal() {
            document.getElementById('controls-modal').classList.remove('active');
        }

        function remapKey(button) {
            alert(`Press a key to map to ${button.toUpperCase()}`);
            
            const handler = (e) => {
                e.preventDefault();
                
                for (const key in emulator.keyMap) {
                    if (emulator.keyMap[key] === button) {
                        delete emulator.keyMap[key];
                    }
                }
                
                emulator.keyMap[e.code] = button;
                
                window.removeEventListener('keydown', handler);
                openControlsModal();
            };
            
            window.addEventListener('keydown', handler);
        }

        window.addEventListener('load', () => {
            initEmulator();
        });

        window.addEventListener('resize', () => {
            if (emulator && emulator.gl) {
                emulator.gl.viewport(0, 0, emulator.canvas.width, emulator.canvas.height);
            }
        });
    </script>
</body>
</html>
