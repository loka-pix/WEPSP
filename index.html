<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PSP Emulator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: manipulation; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #000; 
            color: #eee; 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh; 
            position: fixed;
        }
        
        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #000;
        }
        
        #screen {
            width: 100%;
            height: 100%;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            display: block;
        }
        
        .overlay-controls {
            position: absolute;
            pointer-events: none;
        }
        
        .overlay-controls > * {
            pointer-events: auto;
        }
        
        #menu-btn {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        #menu-btn:active {
            background: rgba(255,255,255,0.3);
            transform: translateX(-50%) scale(0.95);
        }
        
        #fps-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #0f0;
            font-family: monospace;
            z-index: 100;
        }
        
        #dpad {
            position: absolute;
            left: 30px;
            bottom: 100px;
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
            z-index: 50;
        }
        
        .dpad-btn {
            background: rgba(100,100,100,0.5);
            border: 2px solid rgba(255,255,255,0.4);
            color: white;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            transition: all 0.1s;
        }
        
        .dpad-btn:active, .dpad-btn.pressed {
            background: rgba(150,150,150,0.7);
            transform: scale(0.95);
        }
        
        #dpad-up { grid-column: 2; grid-row: 1; }
        #dpad-left { grid-column: 1; grid-row: 2; }
        #dpad-center { grid-column: 2; grid-row: 2; background: rgba(50,50,50,0.3); pointer-events: none; border-color: rgba(255,255,255,0.2); }
        #dpad-right { grid-column: 3; grid-row: 2; }
        #dpad-down { grid-column: 2; grid-row: 3; }
        
        #action-btns {
            position: absolute;
            right: 30px;
            bottom: 100px;
            width: 200px;
            height: 200px;
            z-index: 50;
        }
        
        .action-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid;
            font-size: 18px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            transition: all 0.1s;
        }
        
        .action-btn:active, .action-btn.pressed {
            transform: scale(0.95);
            filter: brightness(1.2);
        }
        
        #btn-triangle {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,255,0,0.5);
            border-color: rgba(0,200,0,0.8);
        }
        
        #btn-triangle:active, #btn-triangle.pressed {
            transform: translateX(-50%) scale(0.95);
        }
        
        #btn-circle {
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            background: rgba(255,0,0,0.5);
            border-color: rgba(200,0,0,0.8);
        }
        
        #btn-circle:active, #btn-circle.pressed {
            transform: translateY(-50%) scale(0.95);
        }
        
        #btn-cross {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,255,0.5);
            border-color: rgba(0,0,200,0.8);
        }
        
        #btn-cross:active, #btn-cross.pressed {
            transform: translateX(-50%) scale(0.95);
        }
        
        #btn-square {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            background: rgba(255,0,255,0.5);
            border-color: rgba(200,0,200,0.8);
        }
        
        #btn-square:active, #btn-square.pressed {
            transform: translateY(-50%) scale(0.95);
        }
        
        .shoulder-btn {
            position: absolute;
            top: 15px;
            background: rgba(80,80,80,0.6);
            border: 2px solid rgba(255,255,255,0.4);
            color: white;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 100;
            user-select: none;
            transition: all 0.1s;
        }
        
        .shoulder-btn:active, .shoulder-btn.pressed {
            background: rgba(120,120,120,0.8);
            transform: translateY(2px);
        }
        
        #btn-L { left: 15px; }
        #btn-R { right: 15px; }
        
        #center-btns {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 50;
        }
        
        .center-btn {
            background: rgba(70,70,70,0.5);
            border: 2px solid rgba(255,255,255,0.4);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
        }
        
        .center-btn:active, .center-btn.pressed {
            background: rgba(100,100,100,0.7);
            transform: scale(0.95);
        }
        
        #analog-stick {
            position: absolute;
            left: 30px;
            bottom: 350px;
            width: 100px;
            height: 100px;
            z-index: 50;
        }
        
        .analog-base {
            width: 100%;
            height: 100%;
            background: rgba(50,50,50,0.4);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .analog-stick-inner {
            width: 60px;
            height: 60px;
            background: rgba(100,100,100,0.6);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: rgba(255,255,255,0.6);
            text-align: center;
            cursor: move;
            position: relative;
        }
        
        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            z-index: 1000;
            padding: 40px 20px 20px 20px;
            overflow-y: auto;
        }
        
        #menu-overlay.active { display: flex; }
        
        #menu-overlay h2 {
            color: #e94560;
            text-shadow: 0 0 10px #e94560;
            margin-bottom: 15px;
            font-size: 24px;
        }
        
        .menu-button {
            background: linear-gradient(to bottom, #e94560, #c13548);
            border: 3px solid #a01030;
            color: white;
            padding: 14px 25px;
            border-radius: 10px;
            font-size: 15px;
            width: 100%;
            max-width: 300px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .menu-button:active {
            transform: translateY(2px);
            background: linear-gradient(to bottom, #ff5577, #e94560);
        }
        
        .file-input { display: none; }
        
        .file-label {
            background: linear-gradient(to bottom, #00d9ff, #0099cc);
            display: block;
            padding: 14px 25px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            width: 100%;
            max-width: 300px;
            border: 3px solid #006688;
            font-weight: bold;
            color: white;
            transition: all 0.1s;
            font-size: 15px;
        }
        
        .file-label:active {
            transform: translateY(2px);
            background: linear-gradient(to bottom, #00ffff, #00d9ff);
        }
        
        #debug-panel {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            font-size: 10px;
            color: #0f0;
            display: none;
            max-width: 250px;
            max-height: 200px;
            overflow-y: auto;
            border: 2px solid #0f0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            z-index: 150;
        }
        
        #debug-panel.active { display: block; }
        
        @media (orientation: landscape) and (max-height: 500px) {
            #dpad {
                left: 20px;
                bottom: 60px;
            }
            
            .dpad-btn {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            
            #action-btns {
                right: 20px;
                bottom: 60px;
                width: 170px;
                height: 170px;
            }
            
            .action-btn {
                width: 60px;
                height: 60px;
                font-size: 16px;
            }
            
            .shoulder-btn {
                padding: 10px 25px;
                font-size: 14px;
            }
            
            #center-btns {
                bottom: 20px;
            }
            
            .center-btn {
                padding: 8px 16px;
                font-size: 12px;
            }
            
            #analog-stick {
                bottom: 250px;
                width: 80px;
                height: 80px;
            }
            
            .analog-stick-inner {
                width: 50px;
                height: 50px;
            }
        }
        
        @media (orientation: portrait) {
            #dpad {
                left: 20px;
                bottom: 80px;
            }
            
            #action-btns {
                right: 20px;
                bottom: 80px;
            }
            
            #analog-stick {
                left: 20px;
                bottom: 320px;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <div id="game-container">
        <canvas id="screen" width="480" height="272"></canvas>
        
        <button id="menu-btn" onclick="openMenu()">▲</button>
        
        <div id="fps-display">FPS: 0</div>
        
        <div class="shoulder-btn" id="btn-L" data-button="L">L</div>
        <div class="shoulder-btn" id="btn-R" data-button="R">R</div>
        
        <div id="dpad" class="overlay-controls">
            <div class="dpad-btn" id="dpad-up" data-button="up">▲</div>
            <div class="dpad-btn" id="dpad-left" data-button="left">◀</div>
            <div id="dpad-center" class="dpad-btn"></div>
            <div class="dpad-btn" id="dpad-right" data-button="right">▶</div>
            <div class="dpad-btn" id="dpad-down" data-button="down">▼</div>
        </div>
        
        <div id="analog-stick" class="overlay-controls">
            <div class="analog-base">
                <div class="analog-stick-inner">Analog<br>Stick</div>
            </div>
        </div>
        
        <div id="action-btns" class="overlay-controls">
            <div class="action-btn" id="btn-triangle" data-button="triangle">△</div>
            <div class="action-btn" id="btn-circle" data-button="circle">○</div>
            <div class="action-btn" id="btn-cross" data-button="cross">✕</div>
            <div class="action-btn" id="btn-square" data-button="square">□</div>
        </div>
        
        <div id="center-btns" class="overlay-controls">
            <div class="center-btn" data-button="select">SELECT</div>
            <div class="center-btn" data-button="start">START</div>
        </div>
        
        <div id="debug-panel">
            <div style="color: #00ffff; font-weight: bold; border-bottom: 1px solid #0f0; margin-bottom: 5px;">PSP DEBUG</div>
            <div id="debug-system">System: PSP | FPS: 0</div>
            <div style="margin-top: 5px; color: #ffff00;">CPU:</div>
            <div id="debug-cpu">PC: 0x00000000</div>
            <div id="debug-registers">v0: 0x00000000</div>
            <div style="margin-top: 5px; color: #ffff00;">Memory:</div>
            <div id="debug-memory">RAM: 32MB</div>
            <div style="margin-top: 5px; color: #ffff00;">GPU:</div>
            <div id="debug-gpu">Cmds: 0 | Verts: 0</div>
        </div>
        
        <div id="menu-overlay">
            <h2>🎮 PSP EMULATOR MENU</h2>
            
            <input type="file" id="bios-input" class="file-input" accept=".zip,.bin,.rom">
            <label for="bios-input" class="file-label">📦 Load PSP BIOS</label>
            
            <input type="file" id="iso-input" class="file-input" accept=".iso,.cso,.chd">
            <label for="iso-input" class="file-label">💿 Load ISO/CHD Game</label>
            
            <input type="file" id="cheat-input-file" class="file-input" accept=".db,.ini">
            <label for="cheat-input-file" class="file-label">🎯 Load Cheat File</label>
            
            <input type="file" id="plugin-input" class="file-input" accept=".zip">
            <label for="plugin-input" class="file-label">🔌 Load Plugin (ZIP)</label>
            
            <input type="file" id="save-import-input" class="file-input" accept=".zip,.json">
            <label for="save-import-input" class="file-label">📥 Import Save Data</label>
            
            <button class="menu-button" onclick="exportSaveData()">💾 Export Save Data</button>
            <button class="menu-button" onclick="saveState()">💫 Save State</button>
            <button class="menu-button" onclick="loadState()">📂 Load State</button>
            <button class="menu-button" onclick="toggleDebug()">🐛 Toggle Debug Mode</button>
            <button class="menu-button" onclick="openKeyMapper()">🎮 Remap Controls</button>
            <button class="menu-button" onclick="toggleFullscreen()">⛶ Fullscreen Mode</button>
            <button class="menu-button" onclick="closeMenu()">▶️ Resume Emulation</button>
        </div>
    </div>

    <script>
    'use strict';

    const PSP_MEMORY_SIZE = 32 * 1024 * 1024;
    const PSP_VRAM_SIZE = 2 * 1024 * 1024;
    const CPU_CLOCK = 333000000;
    const CYCLES_PER_FRAME = Math.floor(CPU_CLOCK / 60);

    class PSPSystem {
        constructor() {
            this.memory = new ArrayBuffer(PSP_MEMORY_SIZE);
            this.ram = new Uint8Array(this.memory);
            this.ramView = new DataView(this.memory);
            this.vram = new Uint8Array(PSP_VRAM_SIZE);
            
            this.cpu = new PSPCPU(this);
            this.gpu = new PSPGPU(this);
            this.audio = new PSPAudio(this);
            this.ge = new PSPGeometry(this);
            
            this.bios = null;
            this.iso = null;
            this.cheats = [];
            this.plugins = [];
            
            this.running = false;
            this.paused = false;
            this.debugMode = false;
            
            this.fps = 0;
            this.frameCount = 0;
            this.lastFPSUpdate = performance.now();
            
            this.canvas = document.getElementById('screen');
            this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
            this.ctx2d = this.gl ? null : this.canvas.getContext('2d');
            
            this.initInput();
            this.initStorage();
            this.initKeyMappings();
            this.resizeCanvas();
            
            window.addEventListener('resize', () => this.resizeCanvas());
            window.addEventListener('orientationchange', () => setTimeout(() => this.resizeCanvas(), 100));
            
            this.log('PSP System initialized');
        }

        resizeCanvas() {
            const container = document.getElementById('game-container');
            this.canvas.width = container.clientWidth;
            this.canvas.height = container.clientHeight;
            if (this.gl) this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        }

        initInput() {
            this.buttons = {
                up: false, down: false, left: false, right: false,
                triangle: false, circle: false, cross: false, square: false,
                L: false, R: false, start: false, select: false
            };
            
            this.analogStick = { x: 0, y: 0 };
            this.analogDragging = false;
            
            document.querySelectorAll('[data-button]').forEach(elem => {
                const button = elem.dataset.button;
                
                ['touchstart', 'mousedown'].forEach(event => {
                    elem.addEventListener(event, (e) => {
                        e.preventDefault();
                        this.buttons[button] = true;
                        elem.classList.add('pressed');
                        this.log(`Button pressed: ${button}`);
                    });
                });
                
                ['touchend', 'mouseup', 'mouseleave'].forEach(event => {
                    elem.addEventListener(event, (e) => {
                        e.preventDefault();
                        this.buttons[button] = false;
                        elem.classList.remove('pressed');
                    });
                });
            });
            
            this.initAnalogStick();
        }
        
        initAnalogStick() {
            const analogStick = document.querySelector('.analog-stick-inner');
            const analogBase = document.querySelector('.analog-base');
            let startX, startY, baseRect;
            
            const handleStart = (e) => {
                e.preventDefault();
                this.analogDragging = true;
                baseRect = analogBase.getBoundingClientRect();
                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                startY = touch.clientY;
            };
            
            const handleMove = (e) => {
                if (!this.analogDragging) return;
                e.preventDefault();
                
                const touch = e.touches ? e.touches[0] : e;
                const deltaX = touch.clientX - (baseRect.left + baseRect.width / 2);
                const deltaY = touch.clientY - (baseRect.top + baseRect.height / 2);
                
                const maxRadius = baseRect.width / 2 - 20;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                let x = deltaX;
                let y = deltaY;
                
                if (distance > maxRadius) {
                    x = (deltaX / distance) * maxRadius;
                    y = (deltaY / distance) * maxRadius;
                }
                
                analogStick.style.transform = `translate(${x}px, ${y}px)`;
                
                this.analogStick.x = x / maxRadius;
                this.analogStick.y = y / maxRadius;
            };
            
            const handleEnd = (e) => {
                if (!this.analogDragging) return;
                e.preventDefault();
                this.analogDragging = false;
                analogStick.style.transform = 'translate(0, 0)';
                this.analogStick.x = 0;
                this.analogStick.y = 0;
            };
            
            analogStick.addEventListener('touchstart', handleStart, { passive: false });
            analogStick.addEventListener('mousedown', handleStart);
            
            window.addEventListener('touchmove', handleMove, { passive: false });
            window.addEventListener('mousemove', handleMove);
            
            window.addEventListener('touchend', handleEnd, { passive: false });
            window.addEventListener('mouseup', handleEnd);
        }

        initKeyMappings() {
            this.keyMap = {
                'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right',
                'KeyX': 'cross', 'KeyZ': 'circle', 'KeyA': 'square', 'KeyS': 'triangle',
                'KeyQ': 'L', 'KeyW': 'R', 'Enter': 'start', 'ShiftRight': 'select'
            };
            
            window.addEventListener('keydown', (e) => {
                const button = this.keyMap[e.code];
                if (button && this.buttons.hasOwnProperty(button)) {
                    this.buttons[button] = true;
                    e.preventDefault();
                    const elem = document.querySelector(`[data-button="${button}"]`);
                    if (elem) elem.classList.add('pressed');
                }
            });
            
            window.addEventListener('keyup', (e) => {
                const button = this.keyMap[e.code];
                if (button && this.buttons.hasOwnProperty(button)) {
                    this.buttons[button] = false;
                    e.preventDefault();
                    const elem = document.querySelector(`[data-button="${button}"]`);
                    if (elem) elem.classList.remove('pressed');
                }
            });
        }

        initStorage() {
            const request = indexedDB.open('PSPEmulatorDB', 1);
            request.onerror = () => this.log('IndexedDB error');
            request.onsuccess = (e) => {
                this.db = e.target.result;
                this.log('Storage ready');
            };
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('saves')) {
                    db.createObjectStore('saves', { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('states')) {
                    db.createObjectStore('states', { keyPath: 'slot' });
                }
            };
        }

        async loadBIOS(file) {
            if (file.name.endsWith('.zip')) {
                this.log('Loading BIOS from ZIP archive...');
                try {
                    const zip = await JSZip.loadAsync(file);
                    this.biosFiles = {};
                    let totalSize = 0;
                    
                    for (const [filename, zipEntry] of Object.entries(zip.files)) {
                        if (!zipEntry.dir) {
                            const ext = filename.split('.').pop().toLowerCase();
                            if (['bin', 'prx', 'rco', 'pbp', 'rom'].includes(ext)) {
                                const data = await zipEntry.async('uint8array');
                                this.biosFiles[filename] = data;
                                totalSize += data.length;
                                this.log(`  - Extracted: ${filename} (${(data.length / 1024).toFixed(2)} KB)`);
                            }
                        }
                    }
                    
                    const mainBiosFiles = Object.keys(this.biosFiles).filter(f => 
                        f.toLowerCase().includes('bios') || 
                        f.toLowerCase().includes('flash') ||
                        f.toLowerCase().endsWith('.bin')
                    );
                    
                    if (mainBiosFiles.length > 0) {
                        this.bios = this.biosFiles[mainBiosFiles[0]];
                        this.ram.set(this.bios.slice(0, Math.min(this.bios.length, 4 * 1024 * 1024)), 0);
                        this.log(`✓ BIOS loaded: ${Object.keys(this.biosFiles).length} files, ${(totalSize / 1024).toFixed(2)} KB total`);
                    } else {
                        this.log('⚠ Warning: No main BIOS file found in ZIP, using HLE mode');
                    }
                } catch (err) {
                    this.log(`✗ BIOS ZIP error: ${err.message}`);
                }
            } else {
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.bios = new Uint8Array(e.target.result);
                    this.biosFiles = { [file.name]: this.bios };
                    this.log(`BIOS loaded: ${(this.bios.length / 1024).toFixed(2)} KB`);
                    this.ram.set(this.bios.slice(0, Math.min(this.bios.length, 4 * 1024 * 1024)), 0);
                };
                reader.readAsArrayBuffer(file);
            }
        }

        loadISO(file) {
            this.log(`Loading ${file.name}...`);
            const reader = new FileReader();
            reader.onload = (e) => {
                this.iso = new Uint8Array(e.target.result);
                this.isoName = file.name;
                this.log(`✓ ISO loaded: ${(this.iso.length / 1024 / 1024).toFixed(2)} MB`);
                
                this.parseISOHeader();
                
                const gameRegion = this.iso.length / 1024 / 1024 / 4;
                const gameOffset = 4 * 1024 * 1024;
                if (gameOffset + this.iso.length <= this.ram.length) {
                    this.ram.set(this.iso.slice(0, Math.min(this.iso.length, 16 * 1024 * 1024)), gameOffset);
                    this.log(`✓ Game data loaded to memory at 0x${gameOffset.toString(16)}`);
                }
                
                closeMenu();
                this.log('🎮 Ready to play! Press START or close menu to begin.');
            };
            reader.readAsArrayBuffer(file);
        }
        
        parseISOHeader() {
            if (!this.iso || this.iso.length < 0x8000) return;
            
            const textDecoder = new TextDecoder('ascii');
            const volumeDescriptorOffset = 0x8000;
            
            if (this.iso[volumeDescriptorOffset] === 0x01) {
                const gameTitle = textDecoder.decode(
                    this.iso.slice(volumeDescriptorOffset + 40, volumeDescriptorOffset + 72)
                ).trim();
                
                if (gameTitle) {
                    this.log(`📀 Game Title: ${gameTitle}`);
                    this.gameTitle = gameTitle;
                }
            }
            
            const umdPattern = new Uint8Array([0x50, 0x53, 0x50, 0x5f, 0x47, 0x41, 0x4d, 0x45]);
            for (let i = 0; i < Math.min(this.iso.length - 8, 100000); i++) {
                let match = true;
                for (let j = 0; j < umdPattern.length; j++) {
                    if (this.iso[i + j] !== umdPattern[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    this.log('✓ Valid PSP_GAME signature found');
                    break;
                }
            }
        }

        loadCheats(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                if (file.name.endsWith('.db')) {
                    this.parseCheatsDB(content);
                } else if (file.name.endsWith('.ini')) {
                    this.parseCheatsINI(content);
                }
                this.log(`Loaded ${this.cheats.length} cheat(s)`);
            };
            reader.readAsText(file);
        }

        parseCheatsDB(content) {
            const lines = content.split('\n');
            let currentCheat = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed.startsWith('_S')) {
                    if (currentCheat) this.cheats.push(currentCheat);
                    currentCheat = { name: trimmed.substring(3).trim(), codes: [], enabled: true };
                } else if (trimmed.startsWith('_L') && currentCheat) {
                    const code = trimmed.substring(3).trim();
                    const parts = code.split(' ');
                    if (parts.length >= 2) {
                        currentCheat.codes.push({
                            address: parseInt(parts[0], 16),
                            value: parseInt(parts[1], 16)
                        });
                    }
                }
            }
            if (currentCheat) this.cheats.push(currentCheat);
        }

        parseCheatsINI(content) {
            const lines = content.split('\n');
            let currentCheat = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
                    if (currentCheat) this.cheats.push(currentCheat);
                    currentCheat = { name: trimmed.slice(1, -1), codes: [], enabled: true };
                } else if (trimmed && currentCheat && trimmed.includes('=')) {
                    const [addrStr, valueStr] = trimmed.split('=');
                    const address = parseInt(addrStr.trim(), 16);
                    const value = parseInt(valueStr.trim(), 16);
                    if (!isNaN(address) && !isNaN(value)) {
                        currentCheat.codes.push({ address, value });
                    }
                }
            }
            if (currentCheat) this.cheats.push(currentCheat);
        }

        loadPlugin(file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const zipData = new Uint8Array(e.target.result);
                    const plugin = await this.parseZIP(zipData);
                    this.plugins.push(plugin);
                    this.log(`Plugin loaded: ${file.name}`);
                } catch (err) {
                    this.log(`Plugin error: ${err.message}`);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        async parseZIP(data) {
            const sig = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
            if (sig !== 0x04034b50) throw new Error('Invalid ZIP signature');
            
            const plugin = { files: {} };
            let offset = 0;
            
            while (offset < data.length - 30) {
                const localSig = data[offset] | (data[offset+1] << 8) | (data[offset+2] << 16) | (data[offset+3] << 24);
                if (localSig !== 0x04034b50) break;
                
                const compSize = data[offset + 18] | (data[offset + 19] << 8) | (data[offset + 20] << 16) | (data[offset + 21] << 24);
                const filenameLen = data[offset + 26] | (data[offset + 27] << 8);
                const extraLen = data[offset + 28] | (data[offset + 29] << 8);
                
                const nameStart = offset + 30;
                const filename = String.fromCharCode(...data.slice(nameStart, nameStart + filenameLen));
                
                const dataStart = nameStart + filenameLen + extraLen;
                plugin.files[filename] = data.slice(dataStart, dataStart + compSize);
                
                offset = dataStart + compSize;
            }
            
            return plugin;
        }

        applyCheats() {
            if (!this.running || this.cheats.length === 0) return;
            
            for (const cheat of this.cheats) {
                if (!cheat.enabled) continue;
                
                for (const code of cheat.codes) {
                    const addr = code.address & 0x1FFFFFFF;
                    if (addr < this.ram.length - 3) {
                        this.ramView.setUint32(addr, code.value, true);
                    }
                }
            }
        }

        start() {
            this.running = true;
            this.paused = false;
            this.cpu.reset();
            this.gpu.init();
            this.ge.init();
            
            this.log('Emulation started');
            requestAnimationFrame(() => this.mainLoop());
        }

        mainLoop() {
            if (!this.running) return;
            
            if (!this.paused) {
                this.cpu.executeFrame();
                this.applyCheats();
                this.gpu.renderFrame();
            }
            
            this.frameCount++;
            const now = performance.now();
            if (now - this.lastFPSUpdate >= 1000) {
                this.fps = this.frameCount;
                this.frameCount = 0;
                this.lastFPSUpdate = now;
                
                document.getElementById('fps-display').textContent = `FPS: ${this.fps}`;
                
                if (this.debugMode) this.updateDebugInfo();
            }
            
            requestAnimationFrame(() => this.mainLoop());
        }

        saveState(slot = 0) {
            if (!this.db) return this.log('Storage not ready');
            
            const state = {
                slot: slot,
                timestamp: Date.now(),
                ram: Array.from(this.ram.slice(0, 8 * 1024 * 1024)),
                vram: Array.from(this.vram.slice(0, 1 * 1024 * 1024)),
                cpu: this.cpu.getState()
            };
            
            const transaction = this.db.transaction(['states'], 'readwrite');
            transaction.objectStore('states').put(state);
            this.log(`State saved to slot ${slot}`);
        }

        loadState(slot = 0) {
            if (!this.db) return this.log('Storage not ready');
            
            const transaction = this.db.transaction(['states'], 'readonly');
            const request = transaction.objectStore('states').get(slot);
            
            request.onsuccess = () => {
                const state = request.result;
                if (state) {
                    this.ram.set(new Uint8Array(state.ram), 0);
                    this.vram.set(new Uint8Array(state.vram), 0);
                    this.cpu.setState(state.cpu);
                    this.log(`State loaded from slot ${slot}`);
                } else {
                    this.log(`No state in slot ${slot}`);
                }
            };
        }

        async exportSaveData() {
            if (!this.db) return this.log('Storage not ready');
            
            const transaction = this.db.transaction(['saves', 'states'], 'readonly');
            const savesRequest = transaction.objectStore('saves').getAll();
            const statesRequest = transaction.objectStore('states').getAll();
            
            Promise.all([
                new Promise(resolve => savesRequest.onsuccess = () => resolve(savesRequest.result)),
                new Promise(resolve => statesRequest.onsuccess = () => resolve(statesRequest.result))
            ]).then(async ([saves, states]) => {
                const zip = new JSZip();
                
                const exportData = { saves, states, timestamp: Date.now() };
                zip.file('savedata.json', JSON.stringify(exportData, null, 2));
                
                if (saves.length > 0) {
                    const savesFolder = zip.folder('saves');
                    saves.forEach((save, idx) => {
                        savesFolder.file(`save_${idx}.json`, JSON.stringify(save, null, 2));
                    });
                }
                
                if (states.length > 0) {
                    const statesFolder = zip.folder('states');
                    states.forEach(state => {
                        statesFolder.file(`state_${state.slot}.json`, JSON.stringify(state, null, 2));
                    });
                }
                
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `psp_savedata_${Date.now()}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                this.log('✓ Save data exported to ZIP');
            });
        }

        async importSaveData(file) {
            if (file.name.endsWith('.zip')) {
                this.log('Importing save data from ZIP...');
                try {
                    const zip = await JSZip.loadAsync(file);
                    const transaction = this.db.transaction(['saves', 'states'], 'readwrite');
                    const savesStore = transaction.objectStore('saves');
                    const statesStore = transaction.objectStore('states');
                    
                    let importedCount = 0;
                    
                    if (zip.files['savedata.json']) {
                        const content = await zip.files['savedata.json'].async('text');
                        const data = JSON.parse(content);
                        
                        if (data.saves) {
                            data.saves.forEach(save => savesStore.put(save));
                            importedCount += data.saves.length;
                        }
                        
                        if (data.states) {
                            data.states.forEach(state => statesStore.put(state));
                            importedCount += data.states.length;
                        }
                    }
                    
                    for (const [filename, zipEntry] of Object.entries(zip.files)) {
                        if (!zipEntry.dir && filename.endsWith('.json') && filename !== 'savedata.json') {
                            const content = await zipEntry.async('text');
                            const data = JSON.parse(content);
                            
                            if (filename.includes('save_')) {
                                savesStore.put(data);
                                importedCount++;
                            } else if (filename.includes('state_')) {
                                statesStore.put(data);
                                importedCount++;
                            }
                        }
                    }
                    
                    this.log(`✓ Imported ${importedCount} save/state file(s) from ZIP`);
                } catch (err) {
                    this.log(`✗ Import ZIP error: ${err.message}`);
                }
            } else {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        const transaction = this.db.transaction(['saves', 'states'], 'readwrite');
                        
                        if (data.saves) {
                            const savesStore = transaction.objectStore('saves');
                            data.saves.forEach(save => savesStore.put(save));
                        }
                        
                        if (data.states) {
                            const statesStore = transaction.objectStore('states');
                            data.states.forEach(state => statesStore.put(state));
                        }
                        
                        this.log('✓ Save data imported from JSON');
                    } catch (err) {
                        this.log(`✗ Import error: ${err.message}`);
                    }
                };
                reader.readAsText(file);
            }
        }

        updateDebugInfo() {
            if (!this.debugMode) return;
            
            const activeButtons = Object.entries(this.buttons)
                .filter(([_, pressed]) => pressed)
                .map(([btn, _]) => btn.toUpperCase())
                .join(', ') || 'None';
            
            document.getElementById('debug-system').textContent = `System: PSP-1000 | FPS: ${this.fps}`;
            document.getElementById('debug-cpu').textContent = `PC: 0x${this.cpu.pc.toString(16).padStart(8, '0').toUpperCase()}`;
            document.getElementById('debug-registers').textContent = `Buttons: ${activeButtons}`;
            document.getElementById('debug-memory').textContent = `Analog: X=${this.analogStick.x.toFixed(2)}, Y=${this.analogStick.y.toFixed(2)}`;
            document.getElementById('debug-gpu').textContent = `Game: ${this.iso ? '✓ Loaded' : '✗ Not loaded'} | BIOS: ${this.bios ? '✓' : '✗'}`;
        }

        log(message) {
            console.log(`[PSP] ${message}`);
            if (this.debugMode) {
                const panel = document.getElementById('debug-panel');
                const time = new Date().toLocaleTimeString();
                panel.innerHTML += `\n[${time}] ${message}`;
                panel.scrollTop = panel.scrollHeight;
            }
        }
    }

    class PSPCPU {
        constructor(system) {
            this.sys = system;
            this.pc = 0x04000000;
            this.nextPC = this.pc + 4;
            this.registers = new Int32Array(32);
            this.hi = 0;
            this.lo = 0;
            this.cycles = 0;
        }

        reset() {
            this.pc = this.sys.bios ? 0xBFC00000 : 0x08900000;
            this.nextPC = this.pc + 4;
            this.registers.fill(0);
            this.hi = 0;
            this.lo = 0;
            this.cycles = 0;
            this.sys.log('CPU reset');
        }

        executeFrame() {
            const targetCycles = this.cycles + CYCLES_PER_FRAME;
            let instructionsThisFrame = 0;
            
            while (this.cycles < targetCycles && this.sys.running && instructionsThisFrame < 100000) {
                this.step();
                this.cycles++;
                instructionsThisFrame++;
            }
        }

        step() {
            const instruction = this.fetch();
            this.execute(instruction);
            this.pc = this.nextPC;
            this.nextPC += 4;
        }

        fetch() {
            const physAddr = this.pc & 0x1FFFFFFF;
            if (physAddr >= this.sys.ram.length - 3) return 0;
            return this.sys.ramView.getUint32(physAddr, true);
        }

        execute(instruction) {
            const opcode = (instruction >>> 26) & 0x3F;
            const rs = (instruction >>> 21) & 0x1F;
            const rt = (instruction >>> 16) & 0x1F;
            const rd = (instruction >>> 11) & 0x1F;
            const shamt = (instruction >>> 6) & 0x1F;
            const funct = instruction & 0x3F;
            const imm = instruction & 0xFFFF;
            const signExtImm = (imm & 0x8000) ? (imm | 0xFFFF0000) : imm;
            
            switch (opcode) {
                case 0x00:
                    this.executeSpecial(rs, rt, rd, shamt, funct);
                    break;
                case 0x08:
                    this.registers[rt] = (this.registers[rs] + signExtImm) | 0;
                    break;
                case 0x0F:
                    this.registers[rt] = imm << 16;
                    break;
                case 0x23:
                    this.loadWord(rt, rs, signExtImm);
                    break;
                case 0x2B:
                    this.storeWord(rt, rs, signExtImm);
                    break;
            }
            
            this.registers[0] = 0;
        }

        executeSpecial(rs, rt, rd, shamt, funct) {
            switch (funct) {
                case 0x00:
                    this.registers[rd] = this.registers[rt] << shamt;
                    break;
                case 0x08:
                    this.nextPC = this.registers[rs];
                    break;
                case 0x20:
                    this.registers[rd] = (this.registers[rs] + this.registers[rt]) | 0;
                    break;
                case 0x24:
                    this.registers[rd] = this.registers[rs] & this.registers[rt];
                    break;
                case 0x25:
                    this.registers[rd] = this.registers[rs] | this.registers[rt];
                    break;
            }
        }

        loadWord(rt, rs, offset) {
            const addr = (this.registers[rs] + offset) >>> 0;
            const physAddr = addr & 0x1FFFFFFF;
            if (physAddr < this.sys.ram.length - 3) {
                this.registers[rt] = this.sys.ramView.getInt32(physAddr, true);
            }
        }

        storeWord(rt, rs, offset) {
            const addr = (this.registers[rs] + offset) >>> 0;
            const physAddr = addr & 0x1FFFFFFF;
            if (physAddr < this.sys.ram.length - 3) {
                this.sys.ramView.setInt32(physAddr, this.registers[rt], true);
            }
        }

        getState() {
            return {
                pc: this.pc,
                nextPC: this.nextPC,
                registers: Array.from(this.registers),
                hi: this.hi,
                lo: this.lo,
                cycles: this.cycles
            };
        }

        setState(state) {
            this.pc = state.pc;
            this.nextPC = state.nextPC;
            this.registers.set(state.registers);
            this.hi = state.hi;
            this.lo = state.lo;
            this.cycles = state.cycles;
        }
    }

    class PSPGPU {
        constructor(system) {
            this.sys = system;
            this.commandCount = 0;
        }

        init() {
            if (!this.sys.gl) {
                this.sys.log('WebGL not available, using 2D fallback');
                return;
            }
            
            const gl = this.sys.gl;
            
            const vertexShaderSource = `
                attribute vec3 aPosition;
                attribute vec4 aColor;
                varying vec4 vColor;
                void main() {
                    gl_Position = vec4(aPosition, 1.0);
                    vColor = aColor;
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                varying vec4 vColor;
                void main() {
                    gl_FragColor = vColor;
                }
            `;
            
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);
            
            this.program = gl.createProgram();
            gl.attachShader(this.program, vertexShader);
            gl.attachShader(this.program, fragmentShader);
            gl.linkProgram(this.program);
            
            this.attribs = {
                position: gl.getAttribLocation(this.program, 'aPosition'),
                color: gl.getAttribLocation(this.program, 'aColor')
            };
            
            this.vertexBuffer = gl.createBuffer();
            this.colorBuffer = gl.createBuffer();
            
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            this.sys.log('GPU initialized');
        }

        renderFrame() {
            if (this.sys.gl) {
                this.renderWebGL();
            } else if (this.sys.ctx2d) {
                this.render2D();
            }
        }

        renderWebGL() {
            const gl = this.sys.gl;
            
            gl.viewport(0, 0, this.sys.canvas.width, this.sys.canvas.height);
            gl.clearColor(0.0, 0.0, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            if (!this.program) return;
            
            gl.useProgram(this.program);
            
            const time = performance.now() / 1000;
            const angle = time * 0.5;
            
            const vertices = [
                Math.cos(angle) * 0.5, Math.sin(angle) * 0.5, 0.0,
                Math.cos(angle + 2.09) * 0.5, Math.sin(angle + 2.09) * 0.5, 0.0,
                Math.cos(angle + 4.19) * 0.5, Math.sin(angle + 4.19) * 0.5, 0.0
            ];
            
            const colors = [
                1.0, 0.0, 0.0, 1.0,
                0.0, 1.0, 0.0, 1.0,
                0.0, 0.0, 1.0, 1.0
            ];
            
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(this.attribs.position);
            gl.vertexAttribPointer(this.attribs.position, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(this.attribs.color);
            gl.vertexAttribPointer(this.attribs.color, 4, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        render2D() {
            const ctx = this.sys.ctx2d;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, this.sys.canvas.width, this.sys.canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '20px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('PSP Emulator', this.sys.canvas.width / 2, this.sys.canvas.height / 2 - 80);
            
            if (this.sys.gameTitle) {
                ctx.fillStyle = '#0ff';
                ctx.font = '16px monospace';
                ctx.fillText(`Game: ${this.sys.gameTitle}`, this.sys.canvas.width / 2, this.sys.canvas.height / 2 - 50);
            }
            
            if (this.sys.iso) {
                ctx.fillStyle = '#0f0';
                ctx.font = '14px monospace';
                ctx.fillText('✓ Game Loaded - Controls Active', this.sys.canvas.width / 2, this.sys.canvas.height / 2 - 20);
            } else {
                ctx.fillStyle = '#888';
                ctx.font = '14px monospace';
                ctx.fillText('Load BIOS and ISO to begin', this.sys.canvas.width / 2, this.sys.canvas.height / 2 - 20);
            }
            
            ctx.fillStyle = '#ff0';
            ctx.font = '12px monospace';
            ctx.fillText(`FPS: ${this.sys.fps}`, this.sys.canvas.width / 2, this.sys.canvas.height / 2 + 10);
            
            const activeButtons = Object.entries(this.sys.buttons)
                .filter(([_, pressed]) => pressed)
                .map(([btn, _]) => btn);
            
            if (activeButtons.length > 0) {
                ctx.fillStyle = '#f0f';
                ctx.font = '12px monospace';
                ctx.fillText(`Active: ${activeButtons.join(', ')}`, this.sys.canvas.width / 2, this.sys.canvas.height / 2 + 30);
            }
            
            if (Math.abs(this.sys.analogStick.x) > 0.1 || Math.abs(this.sys.analogStick.y) > 0.1) {
                ctx.fillStyle = '#0ff';
                ctx.font = '12px monospace';
                ctx.fillText(`Analog: (${this.sys.analogStick.x.toFixed(2)}, ${this.sys.analogStick.y.toFixed(2)})`, 
                    this.sys.canvas.width / 2, this.sys.canvas.height / 2 + 50);
            }
        }

        getState() {
            return { commandCount: this.commandCount };
        }

        setState(state) {
            this.commandCount = state.commandCount;
        }
    }

    class PSPGeometry {
        constructor(system) {
            this.sys = system;
            this.vertices = [];
            this.vertexCount = 0;
        }

        init() {
            this.vertices = [];
            this.vertexCount = 0;
            this.sys.log('Geometry Engine initialized');
        }

        addVertex(x, y, z) {
            this.vertices.push({ x, y, z });
            this.vertexCount++;
        }

        clear() {
            this.vertices = [];
            this.vertexCount = 0;
        }
    }

    class PSPAudio {
        constructor(system) {
            this.sys = system;
            this.audioContext = null;
            this.init();
        }

        init() {
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
                this.sys.log('Audio initialized');
            } catch (e) {
                this.sys.log('Audio not available');
            }
        }

        playTone(frequency, duration, volume = 0.1) {
            if (!this.audioContext) return;
            
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;
            
            oscillator.start();
            oscillator.stop(this.audioContext.currentTime + duration);
        }
    }

    let pspSystem = null;

    function init() {
        pspSystem = new PSPSystem();
        
        document.getElementById('bios-input').addEventListener('change', (e) => {
            if (e.target.files[0]) pspSystem.loadBIOS(e.target.files[0]);
        });
        
        document.getElementById('iso-input').addEventListener('change', (e) => {
            if (e.target.files[0]) pspSystem.loadISO(e.target.files[0]);
        });
        
        document.getElementById('cheat-input-file').addEventListener('change', (e) => {
            if (e.target.files[0]) pspSystem.loadCheats(e.target.files[0]);
        });
        
        document.getElementById('plugin-input').addEventListener('change', (e) => {
            if (e.target.files[0]) pspSystem.loadPlugin(e.target.files[0]);
        });
        
        document.getElementById('save-import-input').addEventListener('change', (e) => {
            if (e.target.files[0]) pspSystem.importSaveData(e.target.files[0]);
        });
        
        pspSystem.start();
        openMenu();
    }

    function openMenu() {
        document.getElementById('menu-overlay').classList.add('active');
        if (pspSystem) pspSystem.paused = true;
    }

    function closeMenu() {
        document.getElementById('menu-overlay').classList.remove('active');
        if (pspSystem) pspSystem.paused = false;
    }

    function toggleDebug() {
        if (!pspSystem) return;
        pspSystem.debugMode = !pspSystem.debugMode;
        document.getElementById('debug-panel').classList.toggle('active');
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    }

    function saveState() {
        if (pspSystem) pspSystem.saveState(0);
    }

    function loadState() {
        if (pspSystem) pspSystem.loadState(0);
    }

    function exportSaveData() {
        if (pspSystem) pspSystem.exportSaveData();
    }

    function openKeyMapper() {
        alert('Key mapping: Arrow Keys=D-Pad, X=Cross, Z=Circle, A=Square, S=Triangle, Q=L, W=R');
    }

    window.addEventListener('load', init);
    window.addEventListener('beforeunload', () => {
        if (pspSystem && pspSystem.running) {
            pspSystem.saveState(999);
        }
    });
    </script>
</body>
</html>
